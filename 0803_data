( 0803 회고 )

**  신규 사용자 상태 확장 대응 회고 (A대상 → B대상·C대상 포함)

📌 개요
이번 작업은 기존에 A대상만 처리하던 권한삭제 배치에
👉 B대상 및 C대상까지 포함해달라는 신규 요구사항이 추가된 것이었다.

🧩 기존 구조
대상자: A대상(user 테이블 內 상태 코드로 판단)

처리 방식:

 - 내부 테이블 user_m(이라 가칭...) 에서 A대상(조건)만 상태값으로 yn 여부를 체크하였음. 
 - 권한 중 일부는 외부 솔루션 연동 API 호출 및 테이블 내 데이터 물리삭제로 권한 삭제

🔄 신규 요구사항
새 대상자 추가: B, C 사용자

차이점:
시스템 권한 삭제는 동일 (외부연동하여, 해당 솔루션의 계정을 삭제하던지 등..)
단, A대상에 대해서는 물리삭제 , B,C 대상은 물리삭제 대상이 아님.

** 고로, 기존과 거의 프로세스가 비슷해서 기존 BATCH를 재활용하자! (하는김에 리팩토링 하자고 생각함..)

✍ 리팩토링으로 가자

새로운 배치 만들기  ===> ❌	중복 코드 증가, 유지보수 복잡
기존 배치 리팩토링  ===> ⭕	로직 거의 동일, 분기만 나눠주면 됨, 확장성 좋음

🛠 리팩토링 포인트
  사용자 상태별 처리 구분 (if user.status == 'A' → 물리삭제)
  결과 로그 처리 방식 통합

📝 회고 포인트 정리
  🔹 개발계 데이터 실수 관련
  이번 작업 중 좋지 않았던 점은,
  개발계에서 테스트를 진행하면서 필터 조건을 제거한 채 데이터를 다루다가, 의도치 않게 모든 권한 데이터를 삭제해버렸다.
  물론 다시 데이터를 적재할 수는 있었지만, 관련 절차를 몰라 복구는 하지 않고 테스트는 최소화한 뒤, 이후 작업은 수동으로 데이터를 생성하여 처리하였다.
  
  이번에는 다행히 대상 건수가 수백 건 수준으로 적었기 때문에 큰 문제는 없었지만,
  향후 수천~수만 건, 혹은 억 단위의 데이터가 될 수도 있으므로 성능과 데이터 안정성을 고려하여 TEMP 테이블을 활용한 테스트 방식이 훨씬 안전하고 효율적이라는 점을 체감했다.
  (다행히 현재 개발계에는 CREATE 권한이 있어, 다음부터는 그리 하는걸로....)

  🔹 메서드 리팩토링 및 프로세스 분리
  기존에는 A 대상에 대해서만 처리하던 메서드가 methodA()처럼 구성되어 있었는데,
  이번 확장된 요건에서는 B 및 C 대상자가 포함되었기에, 이를 구분하여 inactiveUserProcess()로 분리한 것은 좋은 선택이었다고 판단한다.
  
  🔹 @Transactional 내 처리 실패 및 예외 처리 문제
  inactiveUserProcess() 메서드 내부에 @Transactional을 선언했음에도, 이를 감싸는 외부 try-catch 블록에서 throw를 하지 않고 단순 로그만 출력한 것이었다.
  이로 인해 내부 로직에서 실제 물리 삭제가 발생했더라도 예외가 외부로 전달되지 않아 rollback이 일어나지 않는 상황이 발생하였다.

  🔹 예외 로그 기록 미흡으로 인한 디버깅 지연
  예외가 발생했을 때 log.info()로만 메시지를 출력하고 
  정작 e.printStackTrace()나 log.error("...", e)를 남기지 않아 NPE가 발생한 정확한 위치를 추적하지 못하고 시간을 허비한 이슈도 있었다.
  
  개발 중 로그를 간단히 남기려다 보니 발생한 문제로,
  예외 발생 시 반드시 StackTrace를 포함해 기록해야 디버깅 효율을 높일 수 있다는 교훈을 얻었다.
  
  🔹 외부 솔루션 연동 실패와 후속 처리 오류
  또한 C 케이스 처리 중 외부 솔루션 연동에 실패하여 예외가 catch 되었지만, 
  rollback이 발생하지 않아 NullPointerException이 발생했고,
  결과적으로 logUpdate() 시 end_time이 비어 있는 상태로 남아있게 되었다.
  
  이 역시 외부 catch에서 throw를 하지 않았기 때문이며,
  @Transactional을 사용하는 경우 내부 오류가 외부까지 전달되도록 설계해야 한다는 점을 재확인하게 되었다.
  
  🔹 조인 조건 실수
  마지막으로, 조인 조건에서도 실수가 있었다.
  A(퇴사자)는 물리 삭제 대상이기 때문에 A JOIN B LEFT JOIN C 구조가 적절했지만,
  B, C는 물리 삭제되지 않고 계속 존재하므로 다음날에도 다시 조회될 수 있다.
  따라서 이 경우에는 A JOIN B JOIN C 구조로 설계했어야 하며, 그렇게 해야만 userList.size() == exeCnt가 정확히 일치한다.
  
  조인 조건 하나만 잘못 잡아도 배치 결과가 완전히 달라질 수 있으므로
  조인 설계 시 대상 데이터 특성과 삭제 여부를 반드시 고려해야 한다는 교훈을 얻었다.
  
  💬 마무리
  이번 작업을 통해, 단순히 로직만 분기하는 수준을 넘어 
  트랜잭션 처리, 예외 흐름, 조인 조건, 실행 건수 정합성 등
  배치 설계 전반을 더 깊이 고려해야 한다는 것을 실감했다.

  
  





